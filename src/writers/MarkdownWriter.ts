import fs from "fs";
import path from "path";
import {
  IClassDoc,
  INamespace,
  IPropertyDoc,
  ITable,
  ITypeormMarkdownConfig,
} from "../structures";
import { MermaidErdWriter } from "./MermaidErdWriter";

export class MarkdownWriter {
  private lines: string[] = [];
  private config: Required<ITypeormMarkdownConfig>;
  private namespaces: INamespace[];

  constructor(
    {
      entityPath,
      title = "ERD",
      outFilePath = "docs/ERD.md",
      indexTable = false,
    }: ITypeormMarkdownConfig,
    namespaces: INamespace[]
  ) {
    this.config = { entityPath, title, outFilePath, indexTable };
    this.namespaces = namespaces;
  }

  public render() {
    this.lines = [];

    this.writeHeader(this.config.title);
    this.writeTOC(this.namespaces);
    this.writeBodyContent(this.namespaces);

    const directory = path.dirname(this.config.outFilePath);
    if (!fs.existsSync(directory)) {
      fs.mkdirSync(directory, { recursive: true });
    }
    fs.writeFileSync(this.config.outFilePath, this.lines.join("\n"));
  }

  private writeHeader(title: string): void {
    this.lines.push(`# ${title}\n`);
    this.lines.push(
      "> Generated by [`typeorm-markdown-generator`](https://github.com/hermin9804/typeorm-markdown-generator)\n"
    );
    this.lines.push("\n");
  }

  private writeTOC(namespaces: INamespace[]): void {
    this.lines.push("## Table of Contents\n");
    this.lines.push("\n");

    namespaces.forEach((namespace) => {
      this.lines.push(
        `- [${
          namespace.namespaceName
        }](#${namespace.namespaceName.toLowerCase()})`
      );
    });

    this.lines.push("\n");
  }

  private writeBodyContent(namespaces: INamespace[]): void {
    namespaces.forEach((namespace) => {
      this.lines.push(`## ${namespace.namespaceName}\n`);
      this.writeMermaidErd(namespace);
      this.writeNamespaceIndices(namespace.tables);
      namespace.classDocs.forEach((doc) => {
        this.writeDocumentContent(doc);
      });
    });
  }

  private writeMermaidErd(namespace: INamespace): void {
    const erdDiagram = MermaidErdWriter.render(namespace.tables);
    this.lines.push("```mermaid\n" + erdDiagram + "\n```\n");
  }

  private writeNamespaceIndices(tables: ITable[]): void {
    if (!this.config.indexTable) return;
    const allIndices = tables.flatMap((table) =>
      table.indices.map((index) => ({ ...index }))
    );
    if (allIndices.length === 0) return;
    this.lines.push(`### Indexes\n`);
    let indexTable =
      "| Table | Index Name | Columns | Unique | Spatial | Where |\n";
    indexTable +=
      "|-------|-------------|---------|--------|---------|-----------|\n";
    allIndices.forEach((index) => {
      indexTable += `| ${index.tableName} | ${index.indexName} | ${index.columns} | ${index.isUnique} | ${index.isSpatial} | ${index.where} |\n`;
    });
    indexTable += "\n";
    this.lines.push(indexTable);
  }

  private writeDocumentContent(classDoc: IClassDoc): void {
    this.lines.push(`### \`${classDoc.className}\`\n`);
    this.lines.push(`${classDoc.docs.join("   \n")}\n`);
    this.lines.push("**Properties**\n");

    classDoc.properties.forEach((prop: IPropertyDoc) => {
      if (prop.docs.length === 1) {
        this.lines.push(`  - \`${prop.propertyName}\`: ${prop.docs.join(" ")}`);
      } else {
        this.lines.push(`  - \`${prop.propertyName}\``);
        prop.docs.forEach((doc) => {
          this.lines.push(`    > ${doc}`);
        });
      }
    });

    this.lines.push("\n");
  }
}
